---
week: 1주차
---

# 모던 자바스크립트 Deep Dive CH04. 변수

## 목차

- [변수의 필요성](#변수의-필요성)
- [변수 선언](#변수-선언)
- [변수 선언의 실행 시점과 변수 호이스팅](#변수-선언의-실행-시점과-변수-호이스팅)
- [값의 할당](#값의-할당)
- [값의 재할당](#값의-재할당)
- [식별자 네이밍 규칙](#식별자-네이밍-규칙)
- [네이밍 컨벤션](#네이밍-컨벤션)
- [정리](#정리)

## 변수의 필요성

먼저 **변수**<sup>variable</sup>란, <u>하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</u>이다.

변수가 왜 필요한가에 대해 책에서는 아래와 같은 예시를 들고있다.

```js
10 + 20
```

컴퓨터(자바스크립트 엔진)는 위 자바스크립트 코드를 아래와 같은 과정으로 실행한다.

1. `10 + 20`의 의미를 해석한다.
2. `+` 연산자의 피연산자를 기억한다.
3. 임의의 메모리 주소에 저장된 피연산자를 읽어들여 연산을 수행한다.
4. 연산 결과인 `30`을 임의의 메모리 주소에 저장한다.

여기서 아래와 같은 의문점이 발생한다.

> 💭 변수가 없어도 메모리 주소를 통해 재사용 할 수 있는 것이 아닌가?
> 
> — *아니다.*

그 이유는 아래와 같다.

* 메모리 주소를 통해 값에 직접 접근하는 일은 치명적인 오류(ex. 시스템 다운)를 발생시킬 가능성이 높은 매우 위험한 일이다.
* 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.
* 동일한 컴퓨터에서 동일한 코드를 실행해도 값이 저장될 메모리 주소는 실행될 때마다 변한다.

따라서 안전하게 값에 접근하기 위해 변수를 사용하는 것이다.

다시말해 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 **재사용**하기 위해 변수를 사용한다.

> ⭐ **변수의 이름, 값, 할당, 참조**
>
> ```
> - 변수 이름/변수명/식별자: 어떤 값을 구별해서 식별할 수 있는 고유한 이름, 값이 아닌 메모리 주소를 기억
> - 변수 값: 변수에 저장된 값
> - 할당/대입/저장: 변수에 값을 저장하는 것
> - 참조: 변수에 저장된 값을 읽어 들이는 것
> ```

## 변수 선언

변수를 사용하려면 반드시 **선언**<sup>declaration</sup>이 필요하다. 여기서 선언이란 <u>변수를 생성하는 것</u>을 의미한다.

`var, let, const` 키워드를 사용해 변수를 선언한다.

`var` 키워드는 ES6 이후로는 권장하지 않지만, `var` 키워드를 사용한 방법으로 먼저 알아보자.

> ⭐ **var 키워드의 단점**
>
> ```
> 블록 레벨 스코프가 아닌 함수 레벨 스코프를 지원해 의도치 않은 전역 변수가 선언된다.
> ```

```js
var message;
```

위 변수 선언문은 자바스크립트 엔진에 의해 2단계에 거쳐 수행된다.

1. 선언 단계: 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다.

> 💭 `undefined`로 초기화는 왜 하는걸까?
> 
> — *초기화 단계가 없다면 메모리 공간에 다른 애플리케이션이 사용했던 값(쓰레기 값)이 남아있을 수 있다.*

## 변수 선언의 실행 시점과 변수 호이스팅

변수 선언은 런타임이 아닌 그 이전 단계에서 먼저 실행된다. 아래 예제로 알아보자.

```js
console.log(message);
// undefined, 변수 선언문보다 앞에 있지만 참조 에러가 발생하지 않음
var message; // 변수 선언문
```

자바스크립트 엔진은 소스코드를 실행하기 전에 평가 과정을 거치면서 실행 준비를 한다.
이때 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아 먼저 실행한다.
이후에 모든 선언문을 제외한 소스코드를 순차적으로 실행하게 된다.

따라서 변수 선언문의 위치에 관계없이 다른 코드보다 먼저 실행돼 어디서든지 변수를 참조할 수 있다.

이와 같이 <u>변수 선언문이 코드의 최상단으로 옮겨진 것처럼 동작하는 특징</u>을 **변수 호이스팅**<sup>hoisting</sup>이라 한다.

변수 선언뿐만 아니라 아래 키워드를 사용한 함수, 클래스 등의 선언도 호이스팅된다.

```js
var, let, const, function, function*, class
```

## 값의 할당

할당 연산자 `=`를 사용해 좌변의 변수에 우변의 값을 할당한다.

```js
// 01.
var message; // 변수 선언
message = 'hello javascript'; // 값의 할당

// 02.
var message = 'hello javascript'; // 변수 선언, 값의 할당
```

자바스크립트 엔진은 변수 선언과 값의 할당을 나누어 각각 실행하기 때문에 위 1번과 2번 코드는 동일하게 동작한다.

이때, <u>변수 선언은 런타임 이전에 실행되지만 값의 할당은 런타임에 실행</u>되기 때문에 주의해야 한다.

```js
console.log(message); // undefined

var message;
message = 'hello javascript';
// 혹은,
var message = 'hello javascript';

console.log(message) // hello javascript
```

추가로, 변수에 값을 할당할 때 `undefined`가 저장된 메모리 공간을 지우고 할당 값을 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 저장하므로 주의하자. 

![image](../images/ch04-01.png)

## 값의 재할당

값의 재할당이란 말 그대로 이미 값이 할당된 변수에 새로운 값을 다시 할당하는 것을 말한다.

이때 만약 값을 재할당할 수 없다면 상수<sup>constant</sup>라 한다. 즉, 상수는 <u>한 번 정해지면 변하지 않는 값</u>이다.

ES6에서는 `const` 키워드를 사용해 상수를 표현한다.

값의 재할당도 역시 값의 할당과 마찬가지로 새로운 메모리 공간을 확보하고 재할당 값을 저장한다.

> 💭 이전에 저장했었던 값들은 어떻게 될까?
> 
> — *불필요한 값들은 가비지 콜렉터에 의해 자동으로 메모리에서 해제된다.*

## 식별자 네이밍 규칙

식별자는 아래와 같은 규칙을 준수해야 한다.

* 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(`_`), 달러(`$`)를 포함할 수 있다.
* 식별자는 숫자로 시작하지 않아야 한다.
* 예약어는 식별자로 사용할 수 없다.

ES5부터 식별자에 유니코드 문자를 허용해 한글 식별자도 사용할 수 있지만 권장하지는 않는다.

## 네이밍 컨벤션

하나 이상의 영어 단어로 구성된 식별자를 가독성 좋게 구분하기 위해 규정한 명명 규칙을 네이밍 컨벤션이라 한다. 주로 아래 4가지 유형이 사용된다.

```
- 카멜 케이스 camelCase
- 스네이크 케이스 snake_case
- 파스칼 케이스 PascalCase
- 헝가리언 케이스 typeHungarianCase
```

자바스크립트에서는 보통 변수나 함수는 카멜 케이스를 생성자 함수, 클래스에는 파스칼 케이스를 사용한다.

## 정리

* 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
* 선언: 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것
* 변수 호이스팅: 변수 선언문이 코드의 최상단으로 옮겨진 것처럼 동작하는 자바스크립트 고유의 특징
* 변수 선언과 값의 할당
  - 변수 선언: 런타임 이전 실행
  - 값의 할당: 런타임에 실행
* 네이밍 컨벤션
  - 변수, 함수: 카멜 케이스 camelCase
  - 생성자 함수, 클래스: 파스칼 케이스 PascalCase
